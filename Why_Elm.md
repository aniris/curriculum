# Почему Elm?

В этом разделе мы поговорим о преимуществах - и недостатках! - использования Elm для создания
front-end приложений.


## Прежде всего, что такое Elm?

**Elm - это язык для построения сложных веб-интерфейсов.** 
Так же, как и CoffeeScript или JSX, Elm компилируется в JavaScript; 
платформа Elm берет ваш Elm и преобразовывает в JavaScript, который может понять любой браузер. 
Во многом он работает схоже с front-end фреймворками JavaScript, такими как React, Angular и Ember.

Однако Elm более мощный, чем frontend фреймворк: 
**это отдельный язык программирования, который заставит вас четко придерживаться его принципов.**

Возможно, вы уже слышали такие слова как **функциональный** и **статически типизируемый** в отношении Elm. 
**Функциональный** означает, что функция всегда возвращает одно и то же значение при одинаковых входных параметрах
_(на самом деле это одна из характеристик чистой функции *примечание переводчика)_.
**Статически типизируемый** означает, что ваш код имеет смысл прежде тем, как вы сможете использовать его в продакшене: 
он не позволит вам запрашивать длину строки у integer или умножать string и float. 
Если ваш код скомпилировался, это значит, что вы выполняете операции, которые имеют смысл. 
Если зададите функции неправильный *тип* значения (например, `String` вместо `Int`), компилятор Elm сразу обнаружит это и даст вам подсказку.


## Итак, почему Elm?

Одна веская причина заключается в том, что **в Elm невозможно допустить целые категории ошибок** таких, как:
  - "Я ожидал, что эта функция вернет число, но вместо этого она ничего не вернула."
  - "Иногда, когда я вызываю эту функцию, она выбрасывает ошибку, хотя я передаю ей одни и те же параметры."
  - "Что-то изменило значение моей переменной, и я не уверен, где это произошло."

Эти ошибки не могут возникнуть в Elm, потому что это строгий язык. 
На самом деле его правила означают, что **Elm приложение никогда не может случайно сломаться.** 
Здесь нет runtime исключений — никаких `undefined is not a function` или `undefined method for nil:NilClass`. 
Следовательно, Elm разработчики проводят намного меньше времени в консоли the Developer Tools, чем JavaScript разработчики,
 и меньше времени в браузере в целом.

Потому Elm чтобы все программы следовали его правилам, 
**компилятор Elm скажет вам точно, что не так с вашей программой, если вы допустили ошибку**. 
Он сообщит вам, если ваше `if/else` возвращает разные по типу значения, 
если вы передаете в функцию слишком большое количество аргументов, 
или если вы ссылаетесь на переменную, которой не существует.

Разработка с Elm напоминает разговор с компилятором, который мягко подталкивает вас к написанию лучшего кода.
Обычно вам даже нет необходимости следить за вашим приложением в браузере, пока вы его разрабатываете — 
вы можете довериться компилятору, который скажет вам, что вы на верном пути.


## Почему не Elm?

Если вы пришли из объекто-ориентированных, динамически типизируемых языков таких, как Ruby или JavaScript, 
Elm может быть похожим для вас на смирительную рубашку. 
Здесь нет циклов `each` или `for` — вместо этого используются другие функции, например, `map`, `filter`, и `fold`. 
Если вам нужно изменить значение в сложной структуре данных, вы не можете просто прочитать и изменить его, как вы бы сделали это в других языках.

Работа с другими библиотеками может быть затруднена из-за конфликтов парадигм. 
Если вам нужно использовать [D3.js](https://d3js.org/) или [Three.js](https://threejs.org/), вы можете испытывать трудности при использовании Elm.

## Изучение Elm

Вы можете задавать себе вопрос, почему вы должны выбрать для изучения Elm, 
который так сильно отличается от других инструментов в экосистеме, особенно, если вы не планируете заниматься им профессионально. 
**Мы аргументируем это тем, что работа в другом окружении, даже на короткое время, может быть очень продуктивной.** 
Возможно ранее вы не имели дело с ограничениями чистых функций, иммутабельности и статической типизации, 
которые вместе образуют базовые концепции **функционального программирования**. 
Эти ограничения подтолкнут вас к решению проблем иными креативными путями, 
и мы надеемся, что изучив эти стратегии, вы сможете применить их и в других языках.

Мы не утверждаем, что функциональное программирование *лучше* других видов программирования, но оно точно *отличается*. 
Мы твердо верим, что изучение нового подхода к программированию сделает вас лучше, как разработчика, 
точно также как изучение иностранных языков заставляет вас ценить структуру и красоту уже знакомых вам языков.

Итак, давайте начинать!
